# -*- coding: utf-8 -*-
"""post-recommender-system-beginner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11qHAeD2NVowxKZCUiNwxWzu4yhChGPwD

# POST RECOMMENDATION SYSTEM

## WHAT IS RECOMMENDER SYSTEM?
* A recommendation engine filters the data using different algorithms and recommends the most relevant items to users. It first captures the past behavior of a customer and based on that, recommends products which the users might be likely to buy.
* We can recommend items to a user which are most popular among all the users.
* We can divide the users into multiple segments based on their preferences (user features) and recommend items   to them based on the segment they belong to.

## APPROACHES TO RECOMMENDER SYSTEM
1. Content Based approach(Metric:Euclidean Distance,Cosine Similarity)
2. Collaborative Filtering(USER-USER or ITEM-ITEM)
"""

#IMPORTING LIBRARIES
import streamlit as st
import pandas as pd
import numpy as np
from sklearn.neighbors import NearestNeighbors
from scipy.sparse import csr_matrix
from sklearn.metrics.pairwise import cosine_similarity


#IMPORTING DATA FROM CSV FILES INTO A DATAFRAME FOR ANALYSIS
post = pd.read_csv("posts.csv")
user = pd.read_csv("users.csv")
view = pd.read_csv("views.csv")

"""### DATA EXPLORATION AND PREPROCESSING"""

user.head()

post.head()

view.head()

user.shape, post.shape, view.shape

user.describe()

post.describe()

view.describe()

user.isna().sum()

post.isna().sum()

view.isna().sum()

post[post["category"].isna()]

post["category"].unique()

post["category"] = post["category"].fillna("random")

post.isna().sum()

"""Creating a dictionary for having actual categories as key and splitted"""

cat = {}
for i in post["category"]:
    cat.update({i:[]})
    for j in i.split("|"):
        cat[i].append(j)
print(cat)

updated_data =  []
for i in cat:
    dummy = post[post['category']==i]
    id = dummy['_id'].values[0]
    title = dummy['title'].values[0]
    post_type = dummy[' post_type'].values[0]
    for j in cat[i]:
        dict1 = {}
        dict1.update({'_id':id})
        dict1.update({'title':title})
        dict1.update({'category':j})
        dict1.update({' post_type':post_type})
        updated_data.append(dict1)

post1 = pd.DataFrame(updated_data)

post1.head()

post1["category"].unique()

view.columns

post1.columns

user.columns

post1.rename(columns={"_id":'post_id'}, inplace = True)

user.rename(columns={"user_id":'post_id'}, inplace = True)

main = pd.merge(view,post1)

main.columns

main.head()

main.info()

main.describe()

"""### MODELING (COLLABORATIVE AND CONTENT BASED FILTERING)

Creating a user user collaborative filtering approach.Creating a matrix with users as rows and categories as columns
"""

print("The number of unique user_ids are {}".format(len(list(main["user_id"].unique()))))
print("The number of unique categories are {}".format(len(list(main["category"].unique()))))
users = list(main["user_id"].unique())
categories = list(main["category"].unique())

#MATRIX WILL BE OF 88,235
user_mat = [[] for i in range(len(users))]
for i in range(len(users)):
    for j in range(len(categories)):
        value = len(main[(main["user_id"]==users[i]) & (main["category"]==categories[j])])
        user_mat[i].append(value)

for i in user_mat[0]:
    print(i,end=" ")

# for creating a sparse matrix
from scipy.sparse import csr_matrix
user_mat = csr_matrix(user_mat)

from sklearn.neighbors import NearestNeighbors
model = NearestNeighbors(metric='cosine', algorithm='brute', n_neighbors=15)

model.fit(user_mat)

def recommender(user_id, data=user_mat, model=model):
    model.fit(data)
    index = users.index(user_id)
    current_user = main[main['user_id']==user_id]
    distances, indices = model.kneighbors(data[index], 15)
    recomendation = []
    for i in indices[0]:
        user = main[main['user_id']==users[i]]
        for i in user['category'].unique():
            if i not in current_user['category'].unique():
                recomendation.append(i)
    return recomendation
#     print(indices)

main[main["user_id"]==users[0]]["category"].unique()

"""Top 10 Recommendations for user[0]"""

recommender(users[0])[:10]

main.head()

main[" post_type"].unique()

"""### CONTENT BASED FILTERING

Now we will be creating a item profile and a user profile for each category.We have the user profile already made.For item profile we can create a profile for if the post falls under a particular category or not.
"""

posts = list(main["post_id"].unique())

item_profiles = {}
for i in categories:
    item_profiles.update({i:[]})
    for j in posts:
        item_profiles[i].append(1) if i in list(main[main['post_id']==j]['category'].unique()) else item_profiles[i].append(0)

# converting lists to vectors or arrays
for i in item_profiles:
    item_profiles[i] = np.array(item_profiles[i])
for i in item_profiles:
    print(i, item_profiles[i])
    break

user_profiles = {}
# Filling the user_profiles
for i in users:
    user_profiles.update({i:[]})
    # finding the current user
    current_user = main[main['user_id']==i]
    # listing all the categories the user has viewed
    current_user_categories = list(current_user['category'].unique())
    # Listing all the posts the user has viewed
    current_user_post = list(current_user['post_id'].unique())

    category_weight = {}
    # create a dummy vector which will store the final vector for the user profile of length equal to posts
    result_vector = np.array([0 for i in range(len(posts))])
    for j in current_user_categories:
        category_weight.update({j:0})
        # Now count how many times j has appeared
        for k in list(current_user['category']):
            if j==k:
                category_weight[j]+=1
        # Now divide it with the length of the current_user_post
        category_weight[j] = category_weight[j]/len(current_user_post)
        # Now we have calculated our weights, Now we will calculate user-profile
        result_vector = result_vector+ (category_weight[j]*item_profiles[j])
    user_profiles[i] = result_vector/len(current_user_post)

from sklearn.metrics.pairwise import cosine_similarity

# we will create a function which will take user_id as argument and will provide recomendation
# all other arguments will be set to some default values.
def recommender1(user_id, user_profiles = user_profiles, item_profiles=item_profiles):
    # calculate the cosine similiraity between the item-profile of all categories and the users user-profile
    # create a dictionary category as key and cosine value as the value
    similarity = {}
    for i in item_profiles:
        similarity.update({i:cosine_similarity(user_profiles[user_id].reshape(1, -1), item_profiles[i].reshape(1, -1))})
    # as we have found the similarity now we will sort it and show the user the posts of the top categories and which the user
    # hasnot viewed yet
    sorted_similarity = sorted(similarity.items(), key=lambda x: x[1], reverse=True)
    # now we will filter those posts that the user hasnot viewed
    user_posts = list(main[main['user_id']==user_id]['post_id'].unique())
    # create recomendation list
    recommendations = []
    # displaying users viewed posts and categories
    print("posts user has viewed:{}".format(user_posts))
    print("categories viewed by users:{}".format(list(main[main['user_id']==user_id]['category'].unique())))
    for i in sorted_similarity:
        category_posts = list(main[main['category']==i[0]]['post_id'].unique())
        for j in category_posts:
            if j not in user_posts:
                recommendations.append([i[0], j])
        # we will recommend top 20 posts to the user
        if len(recommendations)==20:
            break
    for i in recommendations:
        print(i)

recommender1(users[30])

st.title("AI-based Post Recommender")

user_id = st.selectbox("Select a User ID", users)

if st.button("Get Recommendations"):
    st.subheader("Collaborative Filtering")
    colab_recs = recommender(user_id)
    st.write(colab_recs)

    st.subheader("Content-Based Filtering")
    content_recs = recommender1(user_id)
    for category, post_id in content_recs:
        title = post[post["_id"] == post_id]["title"].values[0]
        st.markdown(f"- **{title}** _(Category: {category})_")
